name: Auto Reply to Issues

on:
  issues:
    types: [labeled]

permissions:
  issues: write
  contents: read

# Limit concurrent runs to prevent rate limit issues
concurrency:
  group: auto-reply-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  auto-reply:
    # Only trigger when 'AI Review' label is added, skip bot issues and issues with 'copilot' label
    if: |
      github.event.label.name == 'AI Review' &&
      github.event.issue.user.login != 'github-actions[bot]' &&
      !contains(github.event.issue.labels.*.name, 'copilot')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Build Repository Index
        id: repo_index
        run: |
          echo "Building repository index..."
          
          # Create a detailed summary of the repository structure
          cat > /tmp/repo_index.md << 'EOF'
          # DDNS Repository Structure
          
          ## Project Overview
          DDNS is a Python-based Dynamic DNS client that automatically updates DNS records to match the current IP address.
          - Supports multiple DNS providers
          - Supports IPv4/IPv6, public/private IPs
          - Uses Python standard library only (no external dependencies)
          - Compatible with Python 2.7 and 3.x
          
          ## Directory Structure
          
          ### Core Application (`ddns/`)
          - `__init__.py` - Package initialization and main entry
          - `__main__.py` - CLI entry point
          - `cache.py` - IP caching mechanism
          - `ip.py` - IP detection utilities
          
          ### Configuration (`ddns/config/`)
          - Configuration loading and validation
          
          ### DNS Providers (`ddns/provider/`)
          - `_base.py` - Base provider classes (SimpleProvider, BaseProvider)
          EOF
          
          # List all provider implementations
          echo "- Provider implementations:" >> /tmp/repo_index.md
          for provider in ddns/provider/*.py; do
            name=$(basename "$provider" .py)
            if [[ "$name" != "_"* && "$name" != "__init__" ]]; then
              echo "  - \`$name.py\` - $name DNS provider" >> /tmp/repo_index.md
            fi
          done
          
          # Add utility modules
          cat >> /tmp/repo_index.md << 'EOF'
          
          ### Utilities (`ddns/util/`)
          - HTTP client, configuration management, helper functions
          
          ### Scheduler (`ddns/scheduler/`)
          - Scheduled task management
          
          ## Documentation (`doc/`)
          EOF
          
          # List documentation structure
          echo "### Configuration Guides (\`doc/config/\`)" >> /tmp/repo_index.md
          for doc in doc/config/*.md; do
            if [ -f "$doc" ]; then
              echo "- \`$(basename "$doc")\`" >> /tmp/repo_index.md
            fi
          done
          
          echo "" >> /tmp/repo_index.md
          echo "### Provider Guides (\`doc/providers/\`)" >> /tmp/repo_index.md
          for doc in doc/providers/*.md; do
            if [ -f "$doc" ]; then
              echo "- \`$(basename "$doc")\`" >> /tmp/repo_index.md
            fi
          done
          
          echo "" >> /tmp/repo_index.md
          echo "### Developer Guides (\`doc/dev/\`)" >> /tmp/repo_index.md
          for doc in doc/dev/*.md; do
            if [ -f "$doc" ]; then
              echo "- \`$(basename "$doc")\`" >> /tmp/repo_index.md
            fi
          done
          
          # Add test files
          echo "" >> /tmp/repo_index.md
          echo "## Tests (\`tests/\`)" >> /tmp/repo_index.md
          for test in tests/test_*.py; do
            if [ -f "$test" ]; then
              echo "- \`$(basename "$test")\`" >> /tmp/repo_index.md
            fi
          done
          
          # Add recent changes
          echo "" >> /tmp/repo_index.md
          echo "## Recent Changes (last 5 commits)" >> /tmp/repo_index.md
          git log --oneline --no-decorate -5 >> /tmp/repo_index.md
          
          echo "Repository index built successfully"
      
      - name: Multi-turn AI Response
        id: ai_response
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const apiUrl = process.env.OPENAI_URL;
            const apiKey = process.env.OPENAI_KEY;
            
            if (!apiUrl || !apiKey) {
              core.setFailed('OPENAI_URL and OPENAI_KEY must be set');
              return;
            }
            
            // Read system prompt and repository index
            const systemPrompt = fs.readFileSync('.github/prompts/issue-assistant.md', 'utf8');
            const repoIndex = fs.readFileSync('/tmp/repo_index.md', 'utf8');
            
            // Issue details
            const issueTitle = context.payload.issue.title;
            const issueBody = context.payload.issue.body || '(No description provided)';
            const issueAuthor = context.payload.issue.user.login;
            
            // Helper function to call OpenAI API
            async function callOpenAI(messages, expectJson = true) {
              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'api-key': apiKey
                },
                body: JSON.stringify({
                  messages: messages,
                  temperature: 0.7,
                  max_completion_tokens: 2000,
                  response_format: expectJson ? { type: "json_object" } : undefined
                })
              });
              
              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error: ${response.status} ${errorText}`);
              }
              
              const data = await response.json();
              if (!data.choices?.[0]?.message?.content) {
                throw new Error('Invalid API response structure');
              }
              
              return data.choices[0].message.content.trim();
            }
            
            // Constants
            const MAX_FILES_PER_TURN = 5;
            const MAX_FILE_SIZE = 50000; // 50KB
            
            // Helper function to read file content safely
            function readFileContent(filePath) {
              try {
                const repoRoot = process.cwd();
                
                // Resolve the full path and ensure it's within the repo
                const fullPath = path.resolve(repoRoot, filePath);
                if (!fullPath.startsWith(repoRoot + path.sep) && fullPath !== repoRoot) {
                  return `[Access denied: ${filePath} is outside the repository]`;
                }
                
                // Check if file exists
                if (!fs.existsSync(fullPath)) {
                  return `[File not found: ${filePath}]`;
                }
                
                const stats = fs.statSync(fullPath);
                if (stats.isDirectory()) {
                  return `[${filePath} is a directory, not a file]`;
                }
                
                // Read file with size limit
                if (stats.size > MAX_FILE_SIZE) {
                  // Read only first MAX_FILE_SIZE bytes for large files
                  const fd = fs.openSync(fullPath, 'r');
                  const buffer = Buffer.alloc(MAX_FILE_SIZE);
                  fs.readSync(fd, buffer, 0, MAX_FILE_SIZE, 0);
                  fs.closeSync(fd);
                  return buffer.toString('utf8') + '\n\n[File truncated - exceeded 50KB limit]';
                }
                
                return fs.readFileSync(fullPath, 'utf8');
              } catch (error) {
                return `[Error reading file ${filePath}: ${error.message}]`;
              }
            }
            
            // Helper function to parse JSON response
            function parseJsonResponse(content) {
              let jsonContent = content;
              // Remove markdown code fences if present
              const codeBlockMatch = content.match(/^```(?:json)?\s*\n?([\s\S]*?)\n?```\s*$/);
              if (codeBlockMatch) {
                jsonContent = codeBlockMatch[1].trim();
              }
              return JSON.parse(jsonContent);
            }
            
            try {
              // Conversation history
              const messages = [];
              
              // System prompt for multi-turn conversation
              const multiTurnSystemPrompt = `${systemPrompt}

            ## Multi-turn Conversation Mode

            You are in a multi-turn conversation mode. In each turn, you can either:
            1. Request more files to better understand the issue
            2. Provide your final response with classification

            ### Response Format

            **If you need more files**, respond with:
            \`\`\`json
            {
              "needs_files": true,
              "requested_files": ["path/to/file1.py", "path/to/file2.md"],
              "reason": "Brief explanation of why these files are needed"
            }
            \`\`\`

            **If you have enough information**, respond with:
            \`\`\`json
            {
              "needs_files": false,
              "classification": "bug|feature|question",
              "response": "Your detailed response to the issue..."
            }
            \`\`\`

            ### Guidelines
            - Request only files that are directly relevant to the issue
            - Request at most 5 files per turn
            - After receiving requested files, analyze them and either request more or provide final response
            - You have at most 3 turns to gather information before providing a final response`;

              messages.push({ role: 'system', content: multiTurnSystemPrompt });
              
              // First turn: Provide project context and issue
              const firstTurnPrompt = `## Repository Context

            ${repoIndex}

            ## Issue Details

            **Title:** ${issueTitle}

            **Author:** @${issueAuthor}

            **Body:**
            ${issueBody}

            ---

            Please analyze this issue. If you need to see specific files to provide an accurate response, request them. Otherwise, provide your classification and response.`;

              messages.push({ role: 'user', content: firstTurnPrompt });
              
              let finalClassification = null;
              let finalResponse = null;
              const maxTurns = 3;
              
              for (let turn = 1; turn <= maxTurns; turn++) {
                console.log(`Turn ${turn}/${maxTurns}: Calling OpenAI API...`);
                
                const aiContent = await callOpenAI(messages);
                console.log(`Turn ${turn} response received`);
                
                let parsed;
                try {
                  parsed = parseJsonResponse(aiContent);
                } catch (parseError) {
                  console.log(`Failed to parse JSON in turn ${turn}: ${parseError.message}`);
                  // If we can't parse JSON, treat as final response
                  finalResponse = aiContent;
                  break;
                }
                
                if (!parsed.needs_files || turn === maxTurns) {
                  // Final response
                  finalClassification = parsed.classification?.toLowerCase() || null;
                  finalResponse = parsed.response || aiContent;
                  console.log(`Final response received in turn ${turn}`);
                  break;
                }
                
                // Need more files
                const requestedFiles = parsed.requested_files || [];
                console.log(`Turn ${turn}: Requested files: ${requestedFiles.join(', ')}`);
                
                // Add assistant's response to history
                messages.push({ role: 'assistant', content: aiContent });
                
                // Read requested files and add to conversation
                let fileContents = '## Requested File Contents\n\n';
                for (const filePath of requestedFiles.slice(0, MAX_FILES_PER_TURN)) {
                  const content = readFileContent(filePath);
                  fileContents += `### \`${filePath}\`\n\n\`\`\`\n${content}\n\`\`\`\n\n`;
                }
                
                if (turn < maxTurns) {
                  fileContents += `\nYou have ${maxTurns - turn} turn(s) remaining. Please analyze these files and either request more files or provide your final classification and response.`;
                } else {
                  fileContents += `\nThis is your last turn. Please provide your final classification and response now.`;
                }
                
                messages.push({ role: 'user', content: fileContents });
              }
              
              if (!finalResponse) {
                core.setFailed('Failed to get a valid response after all turns');
                return;
              }
              
              // Post the response as a comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: finalResponse
              });
              console.log('Comment posted successfully');
              
              // Add label based on classification
              if (finalClassification && ['bug', 'feature', 'question'].includes(finalClassification)) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.issue.number,
                    labels: [finalClassification]
                  });
                  console.log(`Label '${finalClassification}' added successfully`);
                } catch (labelError) {
                  console.log(`Failed to add label: ${labelError.message}`);
                }
              }
              
              console.log('AI response workflow completed successfully');
            } catch (error) {
              core.setFailed(`Failed to generate AI response: ${error.message}`);
            }
        env:
          OPENAI_URL: ${{ vars.OPENAI_URL }}
          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
